import org.apache.tools.ant.filters.FixCrLfFilter

plugins {
	id "distribution"
	alias(libs.plugins.offlineDependencies)
	alias(libs.plugins.versions)
	alias(libs.plugins.spotless)
	alias(libs.plugins.sonarqube)
	alias(libs.plugins.spotbugs)
	id("jacoco")
}

dependencies {
	spotbugsPlugins "${libs.plugins.findsecbugsPlugin.get().pluginId}:${libs.plugins.findsecbugsPlugin.get().version}"
}

group = "net.sourceforge.fullsync"
version = '0.11.0'

spotless {
	encoding 'UTF-8'
}

subprojects {
	group = rootProject.group
	version = rootProject.version
	apply plugin: 'com.diffplug.spotless'
	apply plugin: 'jacoco'

	def subproject = delegate
	plugins.withType(JavaPlugin).whenPluginAdded { p ->
		jacocoRootReport.dependsOn subproject.tasks.jacocoTestReport
	}
}

configurations {
	dist
}

gradle.projectsEvaluated {
	def deps = rootProject.dependencies
	subprojects.grep { it.configurations.findByName 'dist' }.each {
		def dep = deps.project path: it.path, configuration: "dist"
		deps.add 'dist', dep
	}
}

tasks.register('renderChangeLog', JavaExec) {
	dependsOn ':fullsync-build-utils:jar'
	mainClass = 'net.sourceforge.fullsync.build.tools.ChangeLogGenerator'
	def versionsDir = layout.projectDirectory.dir("versions")
	def changelogFile = layout.buildDirectory.file("ChangeLog.txt")
	inputs.files(fileTree(versionsDir) {
		include "*.html"
	})
	outputs.files changelogFile
	args "--src-dir", versionsDir.asFile.path, "--pattern", ".*\\.html", "--changelog", changelogFile.get().asFile.path
	doFirst {
		layout.buildDirectory.get().asFile.mkdirs()
	}
}

static def eolFilter(context, eol) {
	context.filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(eol))
}

def manualCopySpec = copySpec {
	into('docs/manual') {
		from('docs/manual') {
			include '**'
		}
		from('resources') {
			include 'fullsync.ico'
			rename('fullsync.ico', 'favicon.ico')
		}
	}
}

def versionsCopySpec = copySpec {
	into('versions') {
		from('versions') {
			include '*.html'
		}
	}
}

distributions {
	linux {
		contents {
			eachFile { FileCopyDetails file ->
				if (file.name.endsWith(".sh")) {
					file.permissions {
						user {
							read = true
							write = true
							execute = true
						}
						group {
							read = true
							execute = true
						}
						other {
							read = true
							execute = true
						}
					}
				}
				if ("fullsync.sh" == file.name) {
					file.name = "fullsync"
				}
			}
			from('LICENSE') {
				eolFilter(delegate, "lf")
				rename('LICENSE', 'LICENSE.txt')
			}
			from(renderChangeLog) {
				eolFilter(delegate, "lf")
			}
			from('resources/images') {
				include 'fullsync.svg'
			}
			with manualCopySpec
			with versionsCopySpec
		}
	}
	mac {
		contents {
			eachFile { FileCopyDetails file ->
				if (file.name.endsWith(".sh")) {
					file.permissions {
						user {
							read = true
							write = true
							execute = true
						}
						group {
							read = true
							execute = true
						}
						other {
							read = true
							execute = true
						}
					}
				}
				if ("fullsync.sh" == file.name) {
					file.name = "fullsync"
				}
			}
			from('LICENSE') {
				filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("lf"))
				rename('LICENSE', 'LICENSE.txt')
			}
			from(renderChangeLog) {
				eolFilter(delegate, "lf")
			}
			with manualCopySpec
			with versionsCopySpec
		}
	}
	windows {
		contents {
			from('resources') {
				include 'fullsync*.exe'
				include 'fullsync*.ini'
			}
			from('LICENSE') {
				eolFilter(delegate, "crlf")
				rename('LICENSE', 'LICENSE.txt')
			}
			from(renderChangeLog) {
				eolFilter(delegate, "crlf")
			}
			with manualCopySpec
			with versionsCopySpec
		}
	}
}

distZip.enabled = false
distTar.enabled = false
linuxDistZip.enabled = false
macDistZip.enabled = false
windowsDistTar.enabled = false

tasks.withType(Tar).configureEach {
	compression = Compression.GZIP
}

[':fullsync-ui:jar', ':fullsync-logger:jar', ':fullsync-core:jar', ':fullsync-assets:jar'].each { taskName ->
	installLinuxDist.dependsOn taskName
	linuxDistTar.dependsOn taskName

	installMacDist.dependsOn taskName
	macDistTar.dependsOn taskName

	installWindowsDist.dependsOn taskName
	windowsDistZip.dependsOn taskName
}

installWindowsDist.dependsOn ':fullsync-launcher:jar'
windowsDistZip.dependsOn ':fullsync-launcher:jar'

assembleDist {
	dependsOn assembleLinuxDist
	dependsOn assembleMacDist
	dependsOn assembleWindowsDist
}

installDist {
	dependsOn installLinuxDist
	dependsOn installMacDist
	dependsOn installWindowsDist
}

static def mapArtifactToFilename(a) {
	def group = a.moduleVersion.id.group
	def classifier = a.classifier ?: ""
	classifier = classifier ? "-${classifier}" : ""
	return "${group}-${a.name}${classifier}.${a.extension}"
}

gradle.projectsEvaluated {
	def buildUltils = project(':fullsync-build-utils')
	renderChangeLog.classpath = buildUltils.configurations.runtimeClasspath + buildUltils.jar.outputs.files

	def ui = project(':fullsync-ui')
	def resolvedUiDist = ui.configurations.dist.resolvedConfiguration
	def commonContents = copySpec {}
	resolvedUiDist.resolvedArtifacts.each { a ->
		commonContents.with copySpec {
			def f = a.file
			into('lib') {
				from(f.path) {
					rename(f.name, mapArtifactToFilename(a))
				}
			}
		}
	}
	commonContents.with copySpec {
		into('lib') {
			from resolvedUiDist.files - resolvedUiDist.resolvedArtifacts*.file
		}
	}
	distributions.linux.contents.with commonContents
	distributions.mac.contents.with commonContents
	distributions.windows.contents.with commonContents

	def launcher = project(':fullsync-launcher')
	def resolvedLauncherDist = launcher.configurations.dist.resolvedConfiguration
	resolvedLauncherDist.resolvedArtifacts.each { a ->
		distributions.windows.contents.with copySpec {
			def f = a.file
			into('lib') {
				from(f.path) {
					rename(f.name, mapArtifactToFilename(a))
				}
			}
		}
	}

	subprojects.findAll { subproject ->
		subproject.pluginManager.hasPlugin('java')
	}.each { subproject ->
		jacocoRootReport.sourceDirectories.from(subproject.jacocoTestReport.sourceDirectories.files)
		jacocoRootReport.classDirectories.from(subproject.jacocoTestReport.classDirectories.files)
		if (subproject.file('src/test/java').exists()) {
			jacocoRootReport.executionData.from(subproject.jacocoTestReport.executionData)
		}
		testReport.reportOn subproject.test
	}
	task test {
		dependsOn ':spotlessCheck'
	}
}

apply plugin: 'jacoco'

jacoco {
	reportsDirectory = reporting.baseDirectory.dir("jacoco")
}

tasks.register('jacocoRootReport', JacocoReport) {
	reports {
		xml.required = true
		html.required = true
		csv.required = false
	}
}

tasks.register('testReport', TestReport) {
	destinationDirectory = layout.buildDirectory.dir("reports/allTests")
}

tasks.sonarqube {
	onlyIf {
		System.properties.'sonar.organization' || System.env.SCRUTINIZER
	}
}

def fullsyncCoreJar = layout.buildDirectory.file("install/${project.name}-mac/lib/net.sourceforge.fullsync-fullsync-core.jar")

tasks.register('run', JavaExec) {
	dependsOn installMacDist
	mainClass = '-jar'
	jvmArgs = ["-XstartOnFirstThread"]
	args fullsyncCoreJar.get().asFile.path, "-v"
	systemProperties = [
		"org.eclipse.swt.graphics.Resource.reportNonDisposed": true
	]
}

tasks.register('debug', JavaExec) {
	dependsOn installLinuxDist
	mainClass = '-jar'
	args fullsyncCoreJar.get().asFile.path, "-v"
	debug = true
	enableAssertions = true
	systemProperties = [
		"org.eclipse.swt.graphics.Resource.reportNonDisposed": true
	]
}

tasks.register('debugLauncher', JavaExec) {
	dependsOn installWindowsDist
	mainClass = '-jar'

	args layout.buildDirectory.file("install/${project.name}-windows/lib/net.sourceforge.fullsync-fullsync-launcher.jar").get().asFile.path, "-v"
	debug = true
	enableAssertions = true
	systemProperties = [
		"org.eclipse.swt.graphics.Resource.reportNonDisposed": true
	]
}

dependencyUpdates {
	revision = "release"
	outputFormatter = "text"
	resolutionStrategy {
		componentSelection { rules ->
			rules.all { ComponentSelection selection ->
				boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm'].any { qualifier ->
					selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
				}
				if (rejected) {
					selection.reject('Release candidate')
					return
				}
				rejected = selection.candidate.version.contains('-')
				if (rejected) {
					selection.reject('SNAPSHOT version')
					return
				}
				rejected = selection.candidate.version ==~ /^\d{8}\..*/
				if (rejected) {
					selection.reject('Strange version... likely snapshot version')
					return
				}
			}
		}
	}
}

if (!System.env.'FULLSYNC_OFFLINE_BUILD') {
	apply from: './offline-build.gradle'
}
